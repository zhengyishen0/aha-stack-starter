# Design System Implementation Guide

## Core Philosophy
**"Developers shouldn't make design decisions"** - All design choices are pre-decided in templates. Developers use semantic components without exposure to design tokens.

## The 3-Layer Architecture

### 1. Primitive Tokens (Generated)
Use tools like Realtime Colors to generate color scales, spacing, typography from minimal input.

### 2. Semantic Tokens (Pre-decided mappings)
Map primitives to meaningful names that hide implementation details.

### 3. Component Layer (Handled by Framework)
React/Astro components provide the final abstraction - no additional token layer needed.

## Implementation

### Step 1: Generate Primitive Tokens
```css
/* tokens/primitives.css - Generated by Realtime Colors or similar */
:root {
  /* Color primitives */
  --blue-50: #eff6ff;
  --blue-100: #dbeafe;
  --blue-200: #bfdbfe;
  --blue-300: #93c5fd;
  --blue-400: #60a5fa;
  --blue-500: #3b82f6;
  --blue-600: #2563eb;
  --blue-700: #1d4ed8;
  --blue-800: #1e40af;
  --blue-900: #1e3a8a;
  
  --gray-50: #f9fafb;
  --gray-100: #f3f4f6;
  --gray-200: #e5e7eb;
  --gray-300: #d1d5db;
  --gray-400: #9ca3af;
  --gray-500: #6b7280;
  --gray-600: #4b5563;
  --gray-700: #374151;
  --gray-800: #1f2937;
  --gray-900: #111827;
  
  /* Spacing primitives */
  --space-xs: 0.5rem;
  --space-sm: 0.75rem;
  --space-md: 1rem;
  --space-lg: 1.5rem;
  --space-xl: 2rem;
  --space-2xl: 3rem;
  
  /* Typography primitives */
  --font-sans: system-ui, -apple-system, sans-serif;
  --text-xs: 0.75rem;
  --text-sm: 0.875rem;
  --text-base: 1rem;
  --text-lg: 1.125rem;
  --text-xl: 1.25rem;
  
  /* Border radius */
  --radius-sm: 0.25rem;
  --radius-md: 0.375rem;
  --radius-lg: 0.5rem;
  --radius-xl: 0.75rem;
}
```

### Step 2: Create Semantic Mappings
```css
/* tokens/semantic.css - Pre-decided design relationships */
:root {
  /* Surface colors */
  --color-background: #ffffff;
  --color-surface: var(--gray-50);
  --color-surface-hover: var(--gray-100);
  
  /* Text colors */
  --color-text-primary: var(--gray-900);
  --color-text-secondary: var(--gray-600);
  --color-text-disabled: var(--gray-400);
  
  /* Border colors */
  --color-border: var(--gray-200);
  --color-border-hover: var(--gray-300);
  
  /* Primary colors */
  --color-primary: var(--blue-600);
  --color-primary-hover: var(--blue-700);
  --color-primary-text: #ffffff;
  
  /* Semantic colors */
  --color-danger: #dc2626;
  --color-danger-hover: #b91c1c;
  --color-success: #16a34a;
  --color-success-hover: #15803d;
  --color-warning: #d97706;
  --color-warning-hover: #b45309;
  
  /* Component-specific decisions */
  --card-bg: var(--color-background);
  --card-text: var(--color-text-primary);
  --card-border: var(--color-border);
  --card-padding: var(--space-lg);
  --card-radius: var(--radius-lg);
  
  --button-padding-x: var(--space-md);
  --button-padding-y: var(--space-sm);
  --button-radius: var(--radius-md);
  --button-font-size: var(--text-sm);
  
  --input-bg: var(--color-background);
  --input-border: var(--color-border);
  --input-padding: var(--space-sm);
  --input-radius: var(--radius-md);
}
```

### Step 3: Define Component Templates
```css
/* templates/components.css - Zero decisions, just apply tokens */

/* Card Template */
.card {
  background: var(--card-bg);
  color: var(--card-text);
  border: 1px solid var(--card-border);
  padding: var(--card-padding);
  border-radius: var(--card-radius);
}

.card-header {
  font-size: var(--text-lg);
  font-weight: 600;
  margin-bottom: var(--space-md);
}

.card-content {
  color: var(--color-text-secondary);
  line-height: 1.5;
}

/* Button Template */
.button {
  padding: var(--button-padding-y) var(--button-padding-x);
  border-radius: var(--button-radius);
  font-size: var(--button-font-size);
  font-weight: 500;
  border: none;
  cursor: pointer;
  transition: all 150ms ease;
  display: inline-flex;
  align-items: center;
  gap: var(--space-xs);
}

.button-primary {
  background: var(--color-primary);
  color: var(--color-primary-text);
}

.button-primary:hover {
  background: var(--color-primary-hover);
}

.button-secondary {
  background: transparent;
  color: var(--color-primary);
  border: 1px solid var(--color-primary);
}

.button-secondary:hover {
  background: var(--color-surface);
}

/* Input Template */
.input {
  width: 100%;
  padding: var(--input-padding);
  background: var(--input-bg);
  border: 1px solid var(--input-border);
  border-radius: var(--input-radius);
  font-size: var(--text-base);
  transition: border-color 150ms ease;
}

.input:focus {
  outline: none;
  border-color: var(--color-primary);
  box-shadow: 0 0 0 3px rgb(59 130 246 / 0.1);
}

/* Layout Templates */
.container {
  max-width: 64rem;
  margin-inline: auto;
  padding-inline: var(--space-lg);
}

.stack {
  display: flex;
  flex-direction: column;
  gap: var(--space-md);
}

.cluster {
  display: flex;
  flex-wrap: wrap;
  gap: var(--space-sm);
  align-items: center;
}
```

### Step 4: Component Implementation
```jsx
// components/Card.jsx
export function Card({ children, className = '' }) {
  return (
    <div className={`card ${className}`}>
      {children}
    </div>
  );
}

export function CardHeader({ children }) {
  return <div className="card-header">{children}</div>;
}

export function CardContent({ children }) {
  return <div className="card-content">{children}</div>;
}

// components/Button.jsx
export function Button({ 
  children, 
  variant = 'primary',
  onClick,
  disabled = false 
}) {
  return (
    <button
      className={`button button-${variant}`}
      onClick={onClick}
      disabled={disabled}
    >
      {children}
    </button>
  );
}

// components/Input.jsx
export function Input({ 
  type = 'text',
  placeholder,
  value,
  onChange,
  ...props 
}) {
  return (
    <input
      className="input"
      type={type}
      placeholder={placeholder}
      value={value}
      onChange={onChange}
      {...props}
    />
  );
}
```

### Step 5: Developer Usage
```jsx
// pages/example.jsx
import { Card, CardHeader, CardContent } from '@/components/Card';
import { Button } from '@/components/Button';
import { Input } from '@/components/Input';

export function ExamplePage() {
  return (
    <div className="container">
      <div className="stack">
        <Card>
          <CardHeader>Welcome</CardHeader>
          <CardContent>
            This is a pre-styled card. Developers make no design decisions.
          </CardContent>
          <div className="cluster">
            <Button>Primary Action</Button>
            <Button variant="secondary">Secondary</Button>
          </div>
        </Card>
        
        <Card>
          <CardHeader>Contact Form</CardHeader>
          <CardContent>
            <div className="stack">
              <Input placeholder="Your email" type="email" />
              <Input placeholder="Your message" />
              <Button>Send Message</Button>
            </div>
          </CardContent>
        </Card>
      </div>
    </div>
  );
}
```

## Dark Mode Support
```css
/* tokens/themes.css */
[data-theme="dark"] {
  /* Only change the semantic tokens */
  --color-background: var(--gray-900);
  --color-surface: var(--gray-800);
  --color-surface-hover: var(--gray-700);
  
  --color-text-primary: var(--gray-50);
  --color-text-secondary: var(--gray-400);
  
  --color-border: var(--gray-700);
  --color-border-hover: var(--gray-600);
  
  /* Components automatically adapt */
}
```

## File Structure
```
design-system/
├── tokens/
│   ├── primitives.css    # Generated from tools
│   ├── semantic.css      # Pre-decided mappings
│   └── themes.css        # Theme variations
├── templates/
│   └── components.css    # Component templates
├── components/
│   ├── Card.jsx
│   ├── Button.jsx
│   └── Input.jsx
└── index.css            # Main entry point
```

## Main CSS File
```css
/* index.css */
@import './tokens/primitives.css';
@import './tokens/semantic.css';
@import './tokens/themes.css';
@import './templates/components.css';

/* Global reset */
* {
  box-sizing: border-box;
  margin: 0;
}

body {
  font-family: var(--font-sans);
  color: var(--color-text-primary);
  background: var(--color-background);
  line-height: 1.5;
}
```

## Key Benefits
1. **Zero Design Decisions** - Developers just use components
2. **Single Source of Truth** - All design in CSS tokens
3. **Runtime Theming** - Change themes with data attributes
4. **No Build Complexity** - Just CSS and components
5. **Framework Agnostic** - Works with React, Vue, Astro, etc.

## Advanced Options

### Using SCSS for Complex Templates
If you need template variants or complex logic, add SCSS:
```scss
@mixin button-variant($size: 'md') {
  @if $size == 'sm' {
    padding: var(--space-xs) var(--space-sm);
    font-size: var(--text-xs);
  } @else if $size == 'lg' {
    padding: var(--space-md) var(--space-lg);
    font-size: var(--text-lg);
  }
}
```

### Adding PostCSS
For production optimization, add PostCSS with minimal plugins:
```javascript
// postcss.config.js
module.exports = {
  plugins: [
    require('autoprefixer'), // Browser compatibility
    // Only add more if truly needed
  ]
}
```

### Using Ström's Method
For mathematical color generation with guaranteed accessibility, consider implementing Ström's color algorithm instead of manual color picking. This generates perfect color scales from a single input color with built-in WCAG compliance.

## Summary
This approach creates a design system where:
- Colors flow from tools → semantic tokens → templates → components
- Developers never see or choose design values
- Design decisions are centralized and reusable
- No complex tooling required